#include <math.h>
#ifdef ceild
# undef ceild
#endif
#ifdef floord
# undef floord
#endif
#ifdef max
# undef max
#endif
#ifdef min
# undef min
#endif
#define ceild(n,d)  ceil(((double)(n))/((double)(d)))
#define floord(n,d) floor(((double)(n))/((double)(d)))
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y))
  int lbv, ubv, lb, ub, lb1, ub1, lb2, ub2;
  int c1, c3, c5;
#pragma acc data copy(M)
{
#pragma acc kernels
{
for (c1 = 0; c1 <= 11; c1++) {
  for (c3 = 0; c3 <= 2; c3++) {
    M[3734052+8*c1+96*c3]=0;
  }
}
for (c1 = 0; c1 <= 11; c1++) {
  M[3734052+8*c1]=M[3734032];
  M[3734148+8*c1]=M[3734052+8*c1]*2;
  M[3734244+8*c1]=M[3734148+8*c1]*3;
}
for (c1 = 0; c1 <= 2; c1++) {
  M[3734052]=M[3733696];
  M[3734148]=M[3733696];
  M[3734244]=M[3733696];
  for (c3 = 0; c3 <= ((4 * c1) + 2); c3++) {
    M[3733660]=M[3734052+8*c3]+M[3734148+8*c3]+M[3734244+8*c3];
    for (c5 = 0; c5 <= 2; c5++) {
      M[3734060+8*c3+96*c5]=M[3733696];
    }
  }
  M[3733660]=M[3734076+32*c1]+M[3734172+32*c1]+M[3734268+32*c1];
}
for (c1 = 0; c1 <= 4; c1++) {
  M[3734052]=M[3733696];
  M[3734148]=M[3733696];
  M[3734244]=M[3733696];
  for (c3 = 0; c3 <= ((2 * c1) + 2); c3++) {
    M[3733660]=M[3734052+8*c3]+M[3734148+8*c3]+M[3734244+8*c3];
    for (c5 = 0; c5 <= 2; c5++) {
      M[3734060+8*c3+96*c5]=M[3733696];
    }
  }
  M[3733660]=M[3734076+16*c1]+M[3734172+16*c1]+M[3734268+16*c1];
}
for (c1 = 0; c1 <= 11; c1++) {
  for (c3 = 0; c3 <= 2; c3++) {
    M[2453520+8*c1+96*c3]=0;
  }
}
for (c1 = 0; c1 <= 4; c1++) {
  for (c3 = 0; c3 <= 2; c3++) {
    M[2453520+16*c1+96*c3]=M[3733696];
  }
}
for (c1 = 0; c1 <= 2; c1++) {
  M[2453520+96*c1]=M[3733696];
}
for (c1 = 0; c1 <= 3; c1++) {
  for (c3 = 0; c3 <= 2; c3++) {
    M[2453536+16*c1+96*c3]=M[3733696];
  }
  M[2453528+16*c1]=M[2453528+16*c1]+M[2453536+16*c1];
}
}
}
